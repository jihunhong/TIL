interface 는 클래스와 비슷한 역할을 한다고 이해하자.
상속도 가능하다는 점도 알아두자.

직접만든 객체의 타입과 값을 지정해줄수 있다.

```ts
interface RSP {
    rock : '0'
    scissors : '134'
    paper : '105'
}

const rsp: RSP = {
    rock : '0',
    scissors : '134',
    paper : '105'
}
```

interface는 중첩된 형태로 각각의 키값들에 관한 타입들을 만들어 줄 수 도있는데
라이브러리의 interface와 중첩시켜 유용하게 사용될 수 있다.

```ts
interface Library {
    foo : ~
    bar : ~
}

interface Library {
    now : string
}
```

interface로 정의한 객체의 형태를 함수의 리턴값 혻은 파라미터에 사용하고 싶을때는 다음과 같이 사용한다.

```ts
function foo(parameter: RSP[keyof RSP]): keyof RSP {
    return bar
}
```

interface에 어떤 키와 밸류가 들어갈지 모르는 경우에는 다음과 같이 사용한다.

```ts
interface example { 
    a : 1
    b : 2
    [key : string] : number
}
```

interface를 사용해 객체를 만들어 줄때

```ts

interface RSP { 
    rock : '0'
    scissors : '134'
    paper : '105'
}

const rsp : RSP = {
    rock : '0',
    scissors : '134',
    paper : '105'
}

```
위 예제에서 rsp의 키값은 Object.keys(rsp)를 사용하지만 keys의 리턴값은 string으로 이루어져있다.
이럴 경우 강제 형변환을 통해 타입을 다시 지정해 줄 수 있다.

```ts
Object.keys(rsp) as ['rock', 'sicssors', 'paper']
```

.find()같은 메서드를 사용할때는 이미 지정 되어있는 타입스크립트에서 undefined의 가능성이 있기 때문에

문제없는 상황에서도 에러의 발생이날수도 있다.

!를 붙여 개발자가 보장하는 문장으로 만들수도 있다.
